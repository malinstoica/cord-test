import { typeCheck, constructErrorBody } from './helpers';
import bodyParser from 'body-parser';
import { Messages } from './constants';
const jsonData = require('./rules.json'); 

export default function (app) {
  app.set('port', process.env.PORT || 3000);
  app.use(bodyParser.json());
  app.use(bodyParser.urlencoded({ extended: true }));
}

/**
 * TBD: middleware that checks the request body and querystring against the
 * existing json configuration in order to ensure that:
 * all required parameters are present
 * all parameters are of the correct type
 * non-existing parameters are blocked
 *
 * @throws throw an error code with a relevant error message
 *
 * @param {object} req request object generated by express
 * @param {object} res response object generated by express
 * @param {function} next middleware function
 */
export const checkAgainstRules = (req, res, next) => {
  // if(req.protocol === "HTTP"){
  //   throw new Error(constructErrorBody(Messages.protocolNotSecure, 505))
  // }

  const cleanPath = req.originalUrl.split("?")[0];
  const requestedPath = jsonData.paths[cleanPath];
  const crudOp = req.method.toLowerCase();

  if(requestedPath){
    const validSchema = requestedPath[crudOp];
    if(validSchema){
      checkAndValidateRequestBodyFor(validSchema.parameters, req);
    } else {
      return next();
    }
  } else {
    throw new Error(constructErrorBody(Messages.pathNotFound, 404))
  }

  return next();
};

const checkAndValidateRequestBodyFor = (schema, request) => {
  if(!schema){
    return;
  }

  let queryRequest;
  let bodyRequest;
  let givenParameters;

  //assume we can only have one type of request input (either body or query)
  switch(schema[0].in) {
    case "query": 
      queryRequest = request.query;
      givenParameters = Object.keys(queryRequest);
      if(Object.keys(queryRequest).length === 0){
        throw new Error(constructErrorBody(Messages.malformedQuery, 400));
      }
      break;
    case "body":
      bodyRequest = request.body;
      givenParameters = Object.keys(bodyRequest);
      if(Object.keys(bodyRequest).length === 0){
        throw new Error(constructErrorBody(Messages.malformedQuery, 400));
      }
      break;
  }

  const schemaForRequestParameters = schema.filter(parameter => givenParameters.includes(parameter.name));

  schemaForRequestParameters.forEach(parameter => {
    switch(parameter.in) {
      case "query":
        typeCheck(parameter, queryRequest[parameter.name])
        break;
      case "body":
        typeCheck(parameter.schema, bodyRequest);
        break;
      default:
        throw new Error(constructErrorBody(Messages.malformedQuery, 400));
    }
  })
}